	Обчислювальна геометрія
Найчастіше, проблеми на геометрію трапляються у двовимірному просторі. 
Розглянемо точку у двовимірному просторі. Це два значення: x і y. Можна зберігати їх у стуктурі 
template <typename T>
struct Point {
	T x, y;
	Point(const T _x=0, const T _y=0): x(_x), y(_y){}
};
де T - це тип значень, наприклад Point<int> чи Point<double>.
Можна формально визначити суму двох точок (x1, y1) + (x2, y2)  =  (x1+x2, y1+y2)
Різниця - аналогічно. Можна визначити оператори + і - для структури.

Тепер розглянем вектор. Багато формул і алгоритмів базується на понятті вектора. 
Фомально вектор визначений напрямом і довжиною. У випадку двовимірного простору його можна 
представити, як x i y. Фактично, можна зберігати вектор, так само, як точку. (Вектор буде побудований 
із точки (0,0) до даної точки, хоча вектор можна паралельно переносити).
Вектор AB із точок A і B можна отримати B-A (через оператор віднімання, який ми визначили раніше) 
Сума векторів  - так само, як і сума точок.

Довжина вектора  (x, y) - sqrt(x*x + y*y), dist(p)=sqrt(p.x*p.x + p.y*p.y)
відстань - завжди дійсне число.
Відстань між двома точками A i B можна порахувати, як довжину вектора, побудованого на двох точок 
dist(B-A);

Скалярний добуток = сумі добутків відповідних координат. (x1, y1)*(x2, y2) = x1*x2 + y1*y2 = 
 cos(AB)*|A|*|B|, де |A| - довжина вектора А, cos(AB) - cos кута між векторами A i B (від A до B). 
 Таким чином можна визначити  cos кута між векторами. І визначити кут. cos(AB) = A*B/(|A|*|B|) 
 
Векторний добуток. Він часто застосовується в обчислювальній геометрії. Він завжди визначений у 
тривимірному просторі, у двовимірному припускаємо, що z=0. Векторний добуток A x B у двовимірному 
просторі має величину x1*y2 - x2*y1 або sin(AB)*|A|*|B|, де |A| - довжина вектора А, sin(AB) - sin 
кута між векторами A i B. sin(AB) = A x B / (|A|*|B|). 
Із формули виходить, що модуль векторного добутку рівний площі паралелограма, побудованого на 
векторах, або півплощі трикутника. Цікаво, що площа паралелограма завжди буде ціле число, якщо 
ветори із цілими числами. Тому немає похибки, порівняно із іншими формулами площ трикутника і 
паралелограма.
Площу многокутника можна порахувати так: розбити на трикутники і додати, але простіше можна 
порахувати, як суму трикутників побудованих на відрізках многокутника і (0, 0) із знаком. 
Коли проходитись по одній стороні від (0, 0) то знак буде додатній, а коли по інші - то від*ємний.
Та площа, що є ззовні многокутника - зкомпенсується і буде 0, а многокутник - залишиться, але із 
знаком + чи -. 
	p - масив точок многокутника.
	double s=0;
	for (int i=0; i<n-1; ++i)
		s += cross_prod(p[i], p[i+1]); // векторний добуток
	s += cross_prod(p[n-1], p[0]);
	s = abs(s/2.0);
 
 Відстань між прямою(задана двома точками А і В) і точкою С. (перпендикуляр) Розглянемо вектори 
 AB і AC. 
 |AB x AC| = sin(AB i AC)*|AB|*|AC|
 |AB x AC| / |AB|  = sin(AB i AC)*|AC| = шукана відстань.
 
 
 Випукла оболонка (Convex Hull). Це найменший випуклий многокутник, який охоплює всі точки.
 (Він повинен проходити через точки, бо він найменший).
 Є багато алгоритмів. Розглянемо два - обхід по Джарвісу і обхід по Грехему.
 Обхід по Джарвісу - базується на тому, що на кожному кроці ми вибираєм ту точку, яка утворює 
 найбільший кут із попередньою вершиною оболонки. Складність О(n*n).
Обхід по Грехему.
Спочатку ми знаходим першу ліву-нижню точку (так само і в Джарвісу). потім сортуємо всі вершини по 
куті. Перші дві вершини додаєм до стеку. Далі проходимся по всіх решта верш, і якщо вершина p
утворює додатній кут із попереднім ребром оболонки, то додаєм p до оболонки, інакше, видаляєм
попередню вершину із стеку і знов перевіряєм p.
складність алгоритму - O(n*log(n))