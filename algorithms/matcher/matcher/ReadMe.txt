	Цей проект присвячений проблемі пошуку підстрічок. Тобто пошук входження одного тексту в інший. 
Зрозуміло, що текст меншої довжини може входити в текст більшої довжини, а не навпаки, тому будемо вважати, 
що потрібно знайти входження коротшого тексту (зразка) в інший текст. Припустимо, що нам відомо яка стрічка є 
зразком (це не важко визначити). І нехай на вхід функції пошуку подається зразок, його довжина, текст, його довжина
(char *p, int n, char *t, int m) і повертає вона перше входження p в  t, тобто перший такий зсув.

    Цей пошук можна реалізувати простим способом - здійснити всеможливі зсуви зразка по тексті і потім зрівнювати 
відповідні символи. Це реалізовано у функції matcher_simple. Вона перебирає всі зсуви від нуля до m-n+1, і перевіряє 
співпадіння за допомогою функції bool is_equal(char *a, char *b, int n). Цей метод пошуку має складність O(m*n). 
Для великого об*яму даних цей алгоритм не ефективний, тому далі буде запропоновані ефективніші алгоритми.

    Аглоритм Рабіна-Карпа. Він полягає у хешуванні тексту для пришвидшення пошуку. Зразок закодовується хеш-функцією,
наприклад - степеневою: p[0]*b^(n-1) + p[1]*b^(n-2) + ... + p[n-1]*b^0. Обчислюємо її для перших n символів тексту t.
Якщо результати функції (для зразка і для першиш n символів тексту) не співпадають, то гарантовано самі стрічки 
не співпадають і ми зразу відкидаємо той варіант. Якщо ж результати рівні, то це не гарантує, що стрічки рівні і 
потрібно посимвольно перевіряти рівність. Потрібно зсувати на позиції зразок по тексту так само як і в першому 
випадку. Порахувати функцію для наступного зсуву по тексті можна одною математичною формулою. Хоча може бути 
потрібно щоб перевіряти рівність стрічок, але ймовірність того що результати хешфункції співпадуть дуже маленька, 
тому на практиці пошук відбуваються дуже швидко, майже O(m+n), але не гарантовано.


	Існує спосіб розв’язання цієї задачі за допомогою математичного механізму - скінченних автоматів без виходу.
Опис скінченних автоматів без виходу.
    Автомат має множину станів. Час дискретний. В кожний момент часу автомат перебуває
в одному стані із множини. Залежно від стану, автомат виконує різні дії. Спочаткуу він в початковому стані - s0.
В кожний момент часу автомат зчитує символ, і переходить в інший стан(або в той самий), в залежності від теперішнього стану 
і від зчитаного символу. Новий стан визначається із заданої функції - фі(стан, символ). Робота автомата - проста:
зчитується почергово символи, після кожного зчитування, автомат переходить в інший стан (або той самий). Деякі стани 
називаються кінцеві. Коли автомат досягає кінцевого стану, вважається, що він сприйняв рядок даних. Автомати застосовуються 
для розпізнавання стрічок, які володіють певними властивостями.
    Побудуємо автомат, який сприйме текст, якщо він містить зразок. Автомат буде призначений тільки для даного зразка, 
але можна будувати автомати для будь-якого зразка. Пронумеруємо стани від 0 до m. Автомат досягне і-того стану, якщо
останні і символи, які сприйнялись, рівні і символам зразка. Зрозуміло, що коли автомат досягне стану m, то це означає 
що останні m символів співпали, тобто зразок входить а текст. причому, останній символ, який прочитали - є останнім 
символом входження. Початковий стан - 0 (це означає що жодного символу не співпало). Побудуємо функцію переходів.
Для кожного стану q і для кожного символу a визначимо наступний стан w. Стан q означає що попередніх зчитаних q 
символів були рівні із першими q символами зразка p (нехай вони рівні pq). Тоді потрібно знайти найбільшу кількість 
співпадінь при зчитуванні символу a - це і буде новий стан. Останні зчитані символі - це pq+a. потрібно, щоб префікс 
слова pq+a збігався із суфіксом p (це і буде новий стан). Перебравши всеможливі суфікси і зрівнявши їх із початком 
зразка, знайдемо найбільший префікс.
    Побудова функцію переходу має складність O(n^3*l), де l - це кількість різних символів. Але найголовніше, 
що вона не залежить від довжини тексту. Це суттєво, коли зразок досить короткий, а текст - довгий. автомат 
побудується дуже швидко, а пошук буде відбуватись, проходячись рівно один раз по кожному символу тексту.

	Наступний алгоритм забезпечує гарантовану лінійну складність O(m+n). Це алгоритм Кнута-Морріса-Пратта.
Це велика оптимізація попереднього алгоритму. Там вводиться додаткова функція яка допомагає визначати 
переходи в автоматі. 